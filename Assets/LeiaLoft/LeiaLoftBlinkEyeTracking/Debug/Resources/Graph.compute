// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
float data[2000];
RWTexture2D<float4> Result;
float maxValue;
float minValue;
int trackingState; //1 = facelocked, 2 = reducingBaseline, 3 = sliding, 4 = increasing baseline

float ChartPosition(float chartMin, float chartMax, float value)
{
	float chartHeight = maxValue - minValue;

	return (1 / chartHeight) * (value - chartMin) * 200;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	int dataToChartY = ChartPosition(minValue, maxValue, data[id.x]); ///data[id.x] / maxValue * 200;
	int dataToChartYLeft = 0;
	int dataToChartYRight = 0;

	if ((id.y / maxValue * 200) % 50 == 0)
	{
		Result[id.xy] = float4(0, 0, 1, 1);
	}

	if (id.x > 0)
	{
		dataToChartYLeft = ChartPosition(minValue, maxValue, data[id.x - 1]); //data[id.x - 1] / maxValue * 200;
	}

	if (id.x < 1999)
	{
		dataToChartYRight = ChartPosition(minValue, maxValue, data[id.x + 1]);  //data[id.x + 1] / maxValue * 200;
	}

	if (abs(dataToChartY - id.y) < 3 || abs(dataToChartYLeft - id.y) < 3 || abs(dataToChartYRight - id.y) < 3)
	{
		Result[id.xy] = float4(1, 0, 0, 1);
	}
	else
	{
		Result[id.xy] = float4(1, 1, 1, 1);
	}
}


